/* 
What does this all mean?

Transcript :

You may have noticed something while talking about Big O. Scalable means we worry only about large inputs. What does the end of the graph look like? If our function is only worrying about really small inputs or we know that our inputs are only going to be, let's say an array of five items, Big O won't matter as much does it? But is it real life? NO. Because as humans we tend to think in here and now. We tend to think that: oh, our website is only going to have a hundred users, that's it. But what if that user base grows? What if our inputs grow? We never know.

When we write code, we wanna write code that can scale so that we don't have to constantly go back and fix things or when things get out of hand, the code breaks. And that's why Big O is so important. To write scalable code, means thinking outside of small inputs, it means thinking long terms, think big about your code and what could happen in the future.

You see, now when we look at methods that we get in a language such as methods in an array when it comes to javascript. We have things like push(), pop(), shift(), unshift(). All this methods which are functions have a cost associated with them, a Big O cost.

For example, when it comes to arrays, when we access the first item of the array for example, it's O(1).

But when we use something like unshift(), well it turns out to be O(n).

We use Big O to measure, why one data structure might be better than others? Why should we use an array instead of object?

(The big graph of the Big O can found in https://bigocheatsheet.com)

Data structures are simply ways to store data, and algorithms are simply functions or ways to use data structures to write our programs, remember our instructions for our machines/computers.

Great programmers have this knowledge where they pick the right data structure, the right algorithms to write good programs.

Data Structures + Algorithms = Programs

Remember our two rules of good code, Readable and Scalable.

What we've learned is the foundation for us to make a decision of which data structure is going to be best.

We'll use Big O to see what is a good solution to a problem and what is a bad solution to a problem.

Most interviews have this core concept. What's the right data structure, and what's the right algorithm to write good programs.

Data Structures + Algorithms = Programs

 */