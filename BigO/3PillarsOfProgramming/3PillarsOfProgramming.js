// 3 Pillars Of Programming

/*
Transcript:
What is good code? By this point, you should be able to talk a little bit. Especially about scalable.

Scalable actually has two things to consider:
1. Speed
2. Memory

Speed, it's what we've been talking about up until now. How fast is our runtime in our code? How much does it take for a function to run? How many operations does it costs?

There's another aspect when it comes to machines, two valuable resources, one is the time and speed of our code. The other one is memory.

Computers have limited memories. Back in the days when computers were just being borned, memory was very-very expensive, we only had a little bit of them. And as time has gone on, we have more and more memories, but it's not infinite.

Our computers run based on speed which is usually dictated by the CPU, and memory, based on how much memory such as RAM or Random Access Memory a computer has. Those are two valuable resources.

How could we talk about memories? We've talked about speed now what about memories? The good news is that memories are fairly simple, not as complicated as speed and won't take as long to learn as much as we have about speed.

Right now, which code is best can be answered with the three pillars of code. Something that we'll take for the rest of our career and grow us as an engineer because from now on, when we write code, we'll have these three things in mind:

One is, we're going to write READABLE, clean code that others can read, that is maintanable.

Second is, SPEED, the type of code that we call TIME COMPLEXITY has a Big O time complexity that is efficient, it scales well.

Third is, MEMORY, what's the memory usage of code? If it uses a lot of memory, that's not good. We might have limited memory on our machine. 
With this one, we use Big O once again to talk about SPACE COMPLEXITY. The same notation but different topic. One is space, the other one is time. One is speed. the other one is memory.


A quick preview:

Most programming code solution usually have a trade-off between speed and memory.
You want things to go faster? Then you might have to sacrifice more memory.
You want less memory? You might have to sacrifice the speed.

*/